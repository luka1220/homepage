{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/PAP_Lab2",
    "result": {"data":{"markdownRemark":{"id":"e6d028ef-359c-583a-a7f9-89407f3240c7","html":"<h1>Introduction</h1>\n<p>The experiments of parallel sorting algorithms are\nconducted on a <strong>e2-highcpu-32 (32 vCPUs, 32 GB)</strong> instance of the GCP.</p>\n<h3>Bubble Sort</h3>\n<p>The sequential and parallel bubble sort algorithm is implemented in a standard manner. While the array is not sorted iterate over it and swap the values next to each other according to the order. The parallel version contains two for-loops, one for swaps from even to odd index and one from odd to even. The complexity is of <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.\nThe parallel version splits the for-loop into a number of chunk that is\nequal to <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span> the maximal number of available threads. After the parallel\nfor-loop, a sequential for-loop performs possible swap operations\nbetween the last element and the first element of two adjacent chunks.\nThis for-loop is smaller then the number of threads and is therefore not\nimportant for the complexity. To move the biggest element to the last\nposition takes at most <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span> iterations. A few unnecessary operation could\nbe conducted, for example given an revers-order, where in the last chunk\na rather small would be moved to the end, but the number of such\noperations is bound and thus the complexity stay in <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> and we can\nexpect speed-ups using parallelism.</p>\n<h3>Merge Sort</h3>\n<p>The sequential merge sort has a complexity of <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n~log~n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace nobreak\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace nobreak\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>. The parallel\nversion of the recursive algorithm executes the two recursive calls in\nparallel with <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>o</mi><mi>m</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">omp</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">p</span></span></span></span></span> <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mi>a</mi><mi>s</mi><mi>k</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">tasks</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">s</span></span></span></span></span>. Before merging the two, the sub-arrays have\nto be sorted. The merging operation it self is not parallelized, which\nwould be possible but only relevant to complete the first recursive\ncalls and out of scope for this work. Thus the speed-up with <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> threads\nwill be below <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>. To not generated to small and to may tasks and\ntherefore unnecessary overhead, we include a threshold on the problem\nsize that stops not to split the the recursion for two parallel tasks.</p>\n<p>Its best not to create more tasks when all threads are processing, thus\nthe threshold for the size is <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi mathvariant=\"normal\">/</mi><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">size/T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">ze</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span> for the recursive generation of\ntasks, as we can assume that tasks of the same recursion level have\nsimilar running times.</p>\n<p>We modified the provided <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>e</mi><mi>r</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">merge</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">e</span></span></span></span></span> function to use memory that is\nallocated in the beginning and given as second pointer argument, to not\nwaist time on the initialization of memory inside the <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>e</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">merger</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span></span></span></span></span> function.\nThis modification accelerated the merge sort overall.</p>\n<h3>Odd Even Sort</h3>\n<p>The odd-even sort algorithm is performing two for-loops, the first one\nonly considering swap operations from even to odd indices and the second\nonly from odd to even. Because the swap operations in the for-loops have\nno dependencies to each other they can be easily parallelized.</p>\n<p>To parallelize the two for-loop we used for each a static scheduling\nthat splits the for-loop in <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span> equally large chunks corresponding to\nthe <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span> threads.</p>\n<h3>Quick sort</h3>\n<p>The parallel quick sort algorithm splits the array in to a number of\nchunk corresponding to the maximal number of threads and applies quick\nsort in parallel on these sub-arrays. Then they are merge together in\npairs of two, as in the merge sort algorithm. This gave good results but\nwe could do better and implemented a true parallel quicksort.</p>\n<p>We implemented the quicksort algorithm from scratch, because using the\n<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>q</mi><mi>s</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">qsort</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">sor</span><span class=\"mord mathnormal\">t</span></span></span></span></span> function of <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&#x3C;</mo><mi>s</mi><mi>t</mi><mi>d</mi><mi>l</mi><mi>i</mi><mi>b</mi><mi mathvariant=\"normal\">.</mi><mi>h</mi><mo>></mo></mrow><annotation encoding=\"application/x-tex\">&#x3C;stdlib.h></annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&#x3C;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">ib</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">></span></span></span></span></span> meant to slower the quick sort\nalgorithm when paralleling with merge operations. We compared both\nvariants and with our implementation of quicksort we achieve greater\nspeedups and the sequential execution is fast by a factor of <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1.4</mn></mrow><annotation encoding=\"application/x-tex\">1.4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1.4</span></span></span></span></span> to\n<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>q</mi><mi>s</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">qsort</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">sor</span><span class=\"mord mathnormal\">t</span></span></span></span></span>. As in the merge sort we us a threshold depending on the number\nof <em>omp-threads</em> to decide where or not to open new <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mi>a</mi><mi>s</mi><mi>k</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">tasks</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">s</span></span></span></span></span>:</p>\n<pre><code>    threshold = N/num_threads;\n\n    void true_parallel_quick_sort(*T, lo, hi){\n        if (hi - lo &#x3C; threshold/4){\n            true_quick_sort(T, lo, hi);\n            return ; \n        }\n        if (lo &#x3C; hi){\n            while (1)\n            {\n                while (T[i]&#x3C;pivot){i++;}\n                while (T[j]>pivot){j--;}\n                if (i >= j){break;}\n                tmp = T[i]; T[i] = T[j]; T[j] = tmp;\n                i++; j--;\n            }\n            #pragma omp task\n            true_parallel_quick_sort(T, lo, j);\n            #pragma omp task\n            true_parallel_quick_sort(T, j+1, hi); \n        }\n    }\n</code></pre>\n<h1>Performance</h1>\n<p>We compare the four different sorting algorithms in the following\nregarding their speedups and efficiency for increasing numbers of CPUs.\nThe experiments are conducted with 2, 4, 8, 16, and 32 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>o</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>M</mi><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">openMP</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">MP</span></span></span></span></span> Threads\nand for uint64 arrays of size <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mo separator=\"true\">,</mo><msup><mn>2</mn><mn>3</mn></msup><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><msup><mn>2</mn><mn>29</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^2, 2^3, ..., 2^{29}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">...</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">29</span></span></span></span></span></span></span></span></span></span></span></span></span> for merge- and\nquicksort and with array sizes of <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mo separator=\"true\">,</mo><msup><mn>2</mn><mn>3</mn></msup><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><msup><mn>2</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^2, 2^3, ..., 2^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">...</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">18</span></span></span></span></span></span></span></span></span></span></span></span></span> for bubble and\nodd-even sort.</p>\n<figure>\n<img src=\"/assets/plots/results-21-03-rand17-speedup.png\" id=\"fig:sppedrand\" style=\"width:100.0%\" alt=\"Speedups with random initialization and the array size up to 2^{17}. The running times to sort an array of size 2^{17} sequentially are the following: mergesort: 33.538, quicksort: 27.307, bubblesort: 78528.911, odd-even sort: 50324.279 in Mcycles\" /><figcaption aria-hidden=\"true\">Figure 1: Speedups with random initialization and the array size up to <span class=\"math inline\">2<sup>17</sup></span>. The running times to sort an array of size <span class=\"math inline\">2<sup>17</sup></span> <strong>sequentially</strong> are the following: mergesort: 33.538, quicksort: 27.307, bubblesort: 78528.911, odd-even sort: 50324.279 in <strong>Mcycles</strong></figcaption>\n</figure>\n<figure>\n<img src=\"/assets/plots/mergequick.png\" id=\"fig:sppedrand29\" style=\"width:50.0%\"alt=\"Speedups with random initialization and the array size up to 2^{29}. The running times to sort an array of size 2^{29} sequentially are the following: mergesort: 252342.816, quicksort: 178990.613 in Mcycles. For 32 threads the running times shrink to 35746.808 (mergesort) and 19651.614 (quicksort)\" /><figcaption aria-hidden=\"true\">Figure 2: Speedups with random initialization and the array size up to <span class=\"math inline\">2<sup>29</sup></span>. The running times to sort an array of size <span class=\"math inline\">2<sup>29</sup></span> <strong>sequentially</strong> are the following: mergesort: 252342.816, quicksort: 178990.613 in <strong>Mcycles</strong>. For <strong>32 threads</strong> the running times shrink to 35746.808 (mergesort) and 19651.614 (quicksort)</figcaption>\n</figure>\n<p>Figure\n<a href=\"#fig:sppedrand\" data-reference-type=\"ref\" data-reference=\"fig:sppedrand\">1</a>\nshows that the parallel merge and quicksort algorithm for the array\nsizes of <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><msup><mn>2</mn><mn>17</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^{14}, ..., 2^{17}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">14</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">...</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">17</span></span></span></span></span></span></span></span></span></span></span></span></span> yields rather small speedup, because the\nrunning time is still short and thus the omp-overhead proportionally\nlarge. The efficiency decreases rapidly with increasing number of\nthreads. Figure\n<a href=\"#fig:running1\" data-reference-type=\"ref\" data-reference=\"fig:running1\">4</a>\nillustrates that parallelisation becomes beneficial only for very large\narrays and consequently longer running times. For arrays of size <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>13</mn></msup></mrow><annotation encoding=\"application/x-tex\">2   \n^{13}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">13</span></span></span></span></span></span></span></span></span></span></span></span></span> multi-threading starts to pay-off for all sorting algorithms, see\nFigure\n<a href=\"#fig:running2\" data-reference-type=\"ref\" data-reference=\"fig:running2\">6</a>.</p>\n<h1>Conclusion</h1>\n<p>Evaluating the algorithms for speedups and total running time, the\nparallel quicksort outperforms in both categories. In general the\nresults show that recursive algorithms can have an advantage over\niterative algorithms such as bubble and odd-even sort because their for\nloop iteration as a fast as their slowest chunk of the for-loop.\nQuicksort might pivot on an non-ideal element but this causes no other\nthreads to wait. Hence when the first <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> partition are performed then\nall <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> threads will continuously work until the array is sorted. The\nmerge sort has such an dependency which sparks in Figure\n<a href=\"#fig:sppedrand29\" data-reference-type=\"ref\" data-reference=\"fig:sppedrand29\">2</a>.\nBesides mergesort needs twice as much memory.\nConcerning the <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> algorithms, even-though it is more\nstraightforward to implement a parallel odd-even sort then a parallel\nbubble sort, the speedup advantage of odd-even is small.</p>","excerpt":"Introduction The experiments of parallel sorting algorithms are\nconducted on a e2-highcpu-32 (32 vCPUs, 32 GB) instance of the GCP. Bubble Sort The…","frontmatter":{"date":"March 22, 2021","slug":"/PAP_Lab2","title":"Parallel Programming for Sorting Algorithms","description":"Second Laboratory of Parallel Algorithms","featuredImage":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/b726d481fb8772c87c0e6e9ca1373167/7af97/results-21-03-rand17-speedup.png","srcSet":"/static/b726d481fb8772c87c0e6e9ca1373167/3fb35/results-21-03-rand17-speedup.png 750w,\n/static/b726d481fb8772c87c0e6e9ca1373167/5e576/results-21-03-rand17-speedup.png 1080w,\n/static/b726d481fb8772c87c0e6e9ca1373167/efa1d/results-21-03-rand17-speedup.png 1366w,\n/static/b726d481fb8772c87c0e6e9ca1373167/7af97/results-21-03-rand17-speedup.png 1800w","sizes":"100vw"},"sources":[{"srcSet":"/static/b726d481fb8772c87c0e6e9ca1373167/7c2d4/results-21-03-rand17-speedup.webp 750w,\n/static/b726d481fb8772c87c0e6e9ca1373167/9ba48/results-21-03-rand17-speedup.webp 1080w,\n/static/b726d481fb8772c87c0e6e9ca1373167/01019/results-21-03-rand17-speedup.webp 1366w,\n/static/b726d481fb8772c87c0e6e9ca1373167/903e4/results-21-03-rand17-speedup.webp 1800w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.4166666666666667}}}}}},"pageContext":{"id":"e6d028ef-359c-583a-a7f9-89407f3240c7","previous":{"id":"de5723f6-91a1-5517-ba87-8ff4858b8e7b","frontmatter":{"slug":"/bachelor-thesis","template":"blog-post","title":"Bachelor Thesis"}},"next":{"id":"c378c5a7-7c4b-54ad-95f5-559e688e5449","frontmatter":{"slug":"/PAP_Lab4","template":"blog-post","title":"Parallel Programming for CFD simulation"}}}},
    "staticQueryHashes": ["2744905544","3050756635","3693023521"]}